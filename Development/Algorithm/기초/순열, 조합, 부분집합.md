# 순열과 조합
---
#### 차이
뽑힌 순서에 의미가 있는지?
	있다 -> **순열**
	없다 -> **조합**
	ex) 비밀번호 -> 중복순열,  로또번호 -> 조합
	
## 순열
---
#### 개념
서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것.
서로 다른 n개 중 r개를 택하는 순열 **$_{n}P_r$**
그리고 nPr은 다음과 같은 식이 성립한다.
	 $_{n}P_r = n * (n-1) * (n-2) * \ldots * (n-r+1)$
	 $nPn = n!$
일반적으로 12 이하의 순열은 1초 안에 풀리지만, DFS 사용시 16 이하까지 가능
##### 팁
###### 방문체크 배열
**boolean** 메모리 효율적(공간복잡도 4배가량 차이)이지만 [사용함, 사용안함]만 구분 가능.
**int** 경우에 따라 [A, B, C, D] 등 결정해야할 때 대등 가능
비트마스킹 사용시 메모리 더 적게 사용
###### static 변수
공통적으로 사용(값 변하지 않음)되는 값의 경우, 매 번 재귀함수의 Parameter로 넘기면 함수 스택마다 N 들어있어서 메모리 낭비
	근데 지역변수로 사용시, static으로 선언한 것 보다 속도가 빠름.

#### 생성
숫자를 한 개씩 뽑아야 함. 이는 <u>반복문 / 재귀</u> 로 구현 가능.
이때, 뽑은 수는 기존 수와 중복되지 않아야 한다.
	=> 가능한 모든 수 시도하되, 기존 수와 중복되지 않게 하나의 수 선택
##### 반복문
n 자리 수를 뽑는다면, **n중 for문**을 돌아야 함
=> for문으로 작성할 수 없음 (n이 미정인 경우). 재귀로 작성해야 함.
##### 재귀
파라미터로 넘어올 값(달라지는 부분) -> 지금 뽑힌 수가 저장될 자리, 뽑는 순서
=> 현재 위치에서 <u>가능한 모든 수 시도</u>하고, 다음 수 뽑으라고 재귀 호출
###### 중복 검사가 필요한 경우
isSelected 배열 만들어서 사용 ( index에 해당하는 숫자 사용중인지 저장하는 Boolean 배열)
true로 바꾸고 -> 재귀 돌리고 -> 다시 false로 만듦.
###### 순열의 작업시간
$_{n}P_1$ (1) 부터 $_{n}P_n$ (n!) 까지. 10! = 360만, 11!  = 4000만 ... => 10! 까지가 한계
##### 예시 - N개의 원소 포함하는 모든 순열 생성하는 재귀 함수 ( 1 <= N <= 10)
```
input[]: 숫자배열, numbers[]: 순열 배열
isSelected[]: 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열
Perm(cnt) // cnt : 현재까지 뽑은 순열 수의 개수
	if cnt == N
		순열 생성 완료
	else
		for i from 0 to N-1
			if isSelected[i] == true then continue
			numbers[cnt] <- input[i]
			isSeleted[i] <- true
			perm(cnt+1)
			isSelected[i] <- false
		end for
```
위와 같이 일자로 쭉 내려가는 경우 괜찮지만, 상황에 따라 여러 갈래로 트리 갈라지는 재귀의 경우, 밑으로 갔다가 상태를 <u>재귀 들어가기 전으로 원상복구</u> 해주는게 꼭 필요.

## 조합
---
#### 개념
서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것
###### 수식
$$_{n}C_r = {n! \over {(n-r)!r!}} (n \ge r)$$
###### 재귀적 표현
$$_{n}C_r = _{n-1}C_{r-1} + _{n-1}C_r$$
$$_{n}C_0 = 1$$
뽑을게 극단적으로 적거나, 많을 때는 경우의 수 적음.
	ex) $_{100}C_1$ -> 100, $_{100}C_{100}$ -> 1
하지만, r이 n의 절반정도만 지나도 엄청나게 늘어남.
	=> 단순하게 구하면 시간복잡도가 과다 해질 수 있음. **최적화가 필요**함.
뽑힌 수 동일한 건 뽑으면 안 됨.
	=> 앞에서 뽑은 수와 중복되는 수 안 나옴.
	=> 앞에서 이 수가 나왔는지 검사할 필요 X (isSelected 필요 X)
##### 예시 - {1, 2, 3, 4} 중 원소 3개를 포함하는 모든 조합을 생성 - 반복문
```
for i from 1 to 4
	for j from i+1 to 4
		for k from j+1 to 4
			print i, j, k
		end for
	end for
end for
```
##### 재귀 호출을 이용한 조합 생성 알고리즘
```
nCr -> n개의 원소 중 r개 원소를 갖는 조합 생성
input[]: n개의 원소를 가지고 있는 배열
numbers[]: 크기 r인 배열, 조합이 저장될 배열

comb(cnt, start) // cnt:현재까지 뽑은 조합 원소 개수, start: 조합 시도할 원소의 시작 인덱스
	if cnt == r
		조합 생성 완료
	else
		for i from start to n-1
			numbers[cnt] <- input[i];
			comb(cnt+1, i+1);
		end for
end comb()
```

##### 예시 - 주사위 던지기
주사위를 3번 던져서 나올 수 있는 모든 경우
-> <u>중복 순열 ( 순서 고려 O )</u>
주사위를 3번 던져서 모두 다른 수가 나올 수 있는 모든 경우
-> <u>순열 ( 순서 고려 O, 중복 X )</u>
주사위를 3번 던진 결과가 다음과 같이 중복되는 경우를 제외하고 나올 수 있는 모든 경우
(중복되는 경우 -> 112, 121, 211)
-> <u>중복 조합 ( 순서 고려 X ) </u>
주사위를 3번 던져서 모두 다른 수가 나올 수 있는 모든 경우
(단, 123, 132, 321 같은 경운는 중복되는 경우로 봄 -> 순서 무관하게 같은걸로 봄)
-> <u>조합 ( 순서 고려 X, 중복 X)</u>

## 부분집합
---
#### 개념
집합의 원소가 n개일 때, 집합에 포함된 원소들을 선택
( 공집합을 포함한 부분집합의 수는 $2^n$개 => 각 원소를 부분집합에 (포함 / 제외) 하는 경우를 모두 적용한 것)
조합 함수의 기저조건인 `cnt==R` 을 `cnt==1, cnt==2, ...` 으로 하면, $_4{C}_1$ , $_4{C}_2$ , $_4{C}_3$   다 해보는 것.
중요 알고리즘 중 다수가 원소들의 그룹에서 **최적의 부분집합**을 찾는 것.
###### 예시 - knapsack
물건을 가방에 (넣는다 / 안 넣는다) -> 경우의 수 두 가지
완탐으로하면 $2^n$ 됨 -> 부분조합 문제
###### 예시 - 집합의 모든 부분집합(Power Set) 생성
Parameter로 어느 위치의 수 고려해야하는 상태인지 넘김.
그리고 수 위치의 (원소 선택 / 선택 안 한다)로 접근
#### 예시 
##### 예시 - 부분 집합의 합
###### 합을 구하는 방법
1) 기저 조건일 때 한 번에 다 구하기
2) 재귀 함수 호출할 때 마다 Parameter로 합 넘겨주기 ( 이러면 Backtracking 가능 )