### 반복과 재귀는 유사한 작업 수행 가능
#### 반복
- 수행하는 작업이 완료될 때 까지 계속 반복
- for, while statement 사용.
#### 재귀
- 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용
- 하나의 큰 문제 -> (해결 쉬운) 더 작은 문제로 쪼개고, 결과들 결합
	- => Divide & Conquer
- 가짓 수 ^ n 승
	- ex) 사방위 탐색을 재귀로 n번 한다 -> 4^n
- *동적인 for문(for문 크기 동적으로 조절하는 것)* 또는 *가지치기(백트래킹)* 문제에선 재귀가 효율적
- **재귀 함수**로 구현
##### 재귀 함수
- 함수 내부에서 직접 또는 간접적으로 자기 자신을 호출하는 함수.
- 자신을 통해 자신을 정의.
	1. 함수에 대한 정의를 명확히 해라 (What)
	2. Flat한 시야 가지기 (Deep하게 생각 X)
	3. 각 재귀의 실행을 결정하는 결정요인(값)은 매개변수로 선언
	4. 기저조건(언제 종료 되는지, 언제 밑바닥 치는지) 존재하는지
- 같은 코드 호출하지만, 파라미터 내용과 처리할 부분은 달라짐.
- 지금 내가 처리할 수 있는건 내가 하고, 나머지는 작은 단위로 던짐
	- 내가 할 수 있는 부분 -> **기저 부분(Basis Part)**
		- 기저 조건은 두 개 이상일 수도 있음.
	- 작은 단위로 던진거 -> **유도 부분(Inductive Part)**
		- => 내가 할 수 있는 부분(지금 가진 매개변수로 할 수있는 일)까지만 생각해라.
			- = *Flat한 시야*
- 함수 호출 -> 프로그램 메모리 구조에서 **스택** 사용
	- 재귀 호출 => *반복적인 스택 사용*을 의미, *메모리 및 속도*에서 **성능저하 발생**
#### 반복 - 재귀 비교
|                |                        재귀                        |         반복          |
|:--------------:|:--------------------------------------------------:|:---------------------:|
|      종료      | 재귀 함수 호출이 종료되는 베이스 케이스(base case) |  반복문의 종료 조건   |
|   수행 시간    |                 (상대적으로) 느림                  |         빠름          |
|  메모리 공간   |               (상대적으로) 많이 사용               |       적게 사용       |
| 소스 코드 길이 |                     짧고 간결                      |         길다          |
| 소스 코드 형태 |                선택 구조(if...else)                | 반복 구조(for, while) |
|  무한 반복시   |                  스택 오버플로우                   |  CPU를 반복해서 점유  |
- *재귀*는 문제 해결을 위한 알고리즘 **설계가 간단하고, 자연스러움**
- 입력값 n이 커질수록 *재귀 알고리즘*은 **반복에 비해 비효율적**
## 예시
#### 예시 - 조합 뽑기 ( 재귀 호출 )
- N개의 수 중, K개 뽑는 조합의 경우의 수
	- 'N개 중 하나 뽑고, 나머지는 니가 뽑아' 하면서 넘김
	- $$ _{n}C_{k} = _{n-1}C_{k-1} + _{n-1}C_{k}$$
- 기저 조건
	- 뽑으려는 원소 N개와 뽑은 원소 수 K가 같을 때 (N == K)
	- 아무것도 선택하지 않은 경우 (nCk -> n == 0)
#### 예시 - 팩토리얼 재귀 함수
- n != n * (n-1)!
```java
// loop
static int factorial1(int n) {
		int res = 1;
		for (int i=n; i>=1; i--) {
			res *= i;
		}
		return res;
	}
	
	static int res = 1;
	static void factorial2(int i) { // i값을 기존 누적값에 곱하는 방식으로 계승을 구한다.
		if(i<1) return;
		res *= i;
		factorial2(i-1);
	}
	
	static int factorial3(int n) { // n! = n * n-1!
//		return n * 나머지 팩토리얼 
		if(n<=1)
			return 1;
	
		return n * factorial3(n-1);
	}
```
#### 예시 - 피보나치 수열 ( 재귀 호출 )
- 문제 제시
	- $$ F_{0} = 0, F_{1} = 1, F_{2} = F_{0}+F_{1} $$
	- 재귀함수로 구현시, 엄청난 중복 호출 존재
	- 이를 효츌적으로 바꾸기 위해, 이전에 계산한 값을 메모리에 저장해 중복 계산 안하도록 하는 방법 사용
		- => **메모이제이션**
			- Parameter가 동일하면, 결과값이 항상 같을 때 써야 함.
#### 예시 - 하노이 탑
- N개의 원판
	- 위 부터 N-1개 원판 들어내기 (임시 기둥으로 옮김)
	- N 번째 원판 목적 기둥으로 옮기기
	- 임시 기둥 N-1개 원판들 목적 기둥으로 옮기기
- 매개 변수 (변하는 요소들)
	- 원판 개수 N, 옮기는 시작 위치 Start, 옮길 때 임시 기둥 Temp, 옮길 때 목적 기둥 End
- 기저 조건
	- N == 1 또는 N-1 != 0인 상황 ( 들어낼 원판 있는 상황 동안 )
